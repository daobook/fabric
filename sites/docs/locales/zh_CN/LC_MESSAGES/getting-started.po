# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Jeff Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-04 01:13+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../getting-started.rst:3
msgid "Getting started"
msgstr ""

#: ../../getting-started.rst:5
msgid ""
"Welcome! This tutorial highlights Fabric's core features; for further "
"details, see the links within, or the documentation index which has links"
" to conceptual and API doc sections."
msgstr ""

#: ../../getting-started.rst:11
msgid "A note about imports"
msgstr ""

#: ../../getting-started.rst:13
msgid ""
"Fabric composes a couple of other libraries as well as providing its own "
"layer on top; user code will most often import from the ``fabric`` "
"package, but you'll sometimes import directly from ``invoke`` or "
"``paramiko`` too:"
msgstr ""

#: ../../getting-started.rst:17
msgid ""
"`Invoke <https://www.pyinvoke.org>`_  implements CLI parsing, task "
"organization, and shell command execution (a generic framework plus "
"specific implementation for local commands.)"
msgstr ""

#: ../../getting-started.rst:21
msgid ""
"Anything that isn't specific to remote systems tends to live in Invoke, "
"and it is often used standalone by programmers who don't need any remote "
"functionality."
msgstr ""

#: ../../getting-started.rst:24
msgid ""
"Fabric users will frequently import Invoke objects, in cases where Fabric"
" itself has no need to subclass or otherwise modify what Invoke provides."
msgstr ""

#: ../../getting-started.rst:27
msgid ""
"`Paramiko <https://www.paramiko.org>`_ implements low/mid level SSH "
"functionality - SSH and SFTP sessions, key management, etc."
msgstr ""

#: ../../getting-started.rst:30
msgid ""
"Fabric mostly uses this under the hood; users will only rarely import "
"from Paramiko directly."
msgstr ""

#: ../../getting-started.rst:33
msgid ""
"Fabric glues the other libraries together and provides its own high level"
" objects too, e.g.:"
msgstr ""

#: ../../getting-started.rst:36
msgid ""
"Subclassing Invoke's context and command-runner classes, wrapping them "
"around Paramiko-level primitives;"
msgstr ""

#: ../../getting-started.rst:38
msgid ""
"Extending Invoke's configuration system by using Paramiko's "
"``ssh_config`` parsing machinery;"
msgstr ""

#: ../../getting-started.rst:40
msgid ""
"Implementing new high-level primitives of its own, such as port-"
"forwarding context managers. (These may, in time, migrate downwards into "
"Paramiko.)"
msgstr ""

#: ../../getting-started.rst:50
msgid "Run commands via Connections and ``run``"
msgstr ""

#: ../../getting-started.rst:52
msgid ""
"The most basic use of Fabric is to execute a shell command on a remote "
"system via SSH, then (optionally) interrogate the result. By default, the"
" remote program's output is printed directly to your terminal, *and* "
"captured. A basic example:"
msgstr ""

#: ../../getting-started.rst:85
msgid ""
"Meet `.Connection`, which represents an SSH connection and provides the "
"core of Fabric's API, such as `~.Connection.run`. `.Connection` objects "
"need at least a hostname to be created successfully, and may be further "
"parameterized by username and/or port number. You can give these "
"explicitly via args/kwargs::"
msgstr ""

#: ../../getting-started.rst:92
msgid ""
"Or by stuffing a ``[user@]host[:port]`` string into the ``host`` argument"
" (though this is purely convenience; always use kwargs whenever ambiguity"
" appears!)::"
msgstr ""

#: ../../getting-started.rst:98
msgid ""
"`.Connection` objects' methods (like `~.Connection.run`) usually return "
"instances of `invoke.runners.Result` (or subclasses thereof) exposing the"
" sorts of details seen above: what was requested, what happened while the"
" remote action occurred, and what the final result was."
msgstr ""

#: ../../getting-started.rst:104
msgid ""
"Many lower-level SSH connection arguments (such as private keys and "
"timeouts) can be given directly to the SSH backend by using the "
":ref:`connect_kwargs argument <connect_kwargs-arg>`."
msgstr ""

#: ../../getting-started.rst:109
msgid "Superuser privileges via auto-response"
msgstr ""

#: ../../getting-started.rst:111
msgid ""
"Need to run things as the remote system's superuser? You could invoke the"
" ``sudo`` program via `~.Connection.run`, and (if your remote system "
"isn't configured with passwordless sudo) respond to the password prompt "
"by hand, as below. (Note how we need to request a remote pseudo-terminal;"
" most ``sudo`` implementations get grumpy at password-prompt time "
"otherwise.)"
msgstr ""

#: ../../getting-started.rst:140
msgid ""
"Giving passwords by hand every time can get old; thankfully Invoke's "
"powerful command-execution functionality includes the ability to :ref"
":`auto-respond <autoresponding>` to program output with pre-defined "
"input. We can use this for ``sudo``:"
msgstr ""

#: ../../getting-started.rst:168
msgid ""
"It's difficult to show in a snippet, but when the above was executed, the"
" user didn't need to type anything; ``mypassword`` was sent to the remote"
" program automatically. Much easier!"
msgstr ""

#: ../../getting-started.rst:173
msgid "The ``sudo`` helper"
msgstr ""

#: ../../getting-started.rst:175
msgid ""
"Using watchers/responders works well here, but it's a lot of boilerplate "
"to set up every time - especially as real-world use cases need more work "
"to detect failed/incorrect passwords."
msgstr ""

#: ../../getting-started.rst:179
msgid ""
"To help with that, Invoke provides a `Context.sudo "
"<invoke.context.Context.sudo>` method which handles most of the "
"boilerplate for you (as `.Connection` subclasses "
"`~invoke.context.Context`, it gets this method for free.) "
"`~invoke.context.Context.sudo` doesn't do anything users can't do "
"themselves - but as always, common problems are best solved with commonly"
" shared solutions."
msgstr ""

#: ../../getting-started.rst:186
msgid ""
"All the user needs to do is ensure the ``sudo.password`` "
":doc:`configuration value </concepts/configuration>` is filled in (via "
"config file, environment variable, or :option:`--prompt-for-sudo-"
"password`) and `.Connection.sudo` handles the rest. For the sake of "
"clarity, here's an example where a library/shell user performs their own "
"`getpass`-based password prompt:"
msgstr ""

#: ../../getting-started.rst:228
msgid ""
"We filled in the sudo password up-front at runtime in this example; in "
"real-world situations, you might also supply it via the configuration "
"system (perhaps using environment variables, to avoid polluting config "
"files), or ideally, use a secrets management system."
msgstr ""

#: ../../getting-started.rst:235
msgid "Transfer files"
msgstr ""

#: ../../getting-started.rst:237
msgid ""
"Besides shell command execution, the other common use of SSH connections "
"is file transfer; `.Connection.put` and `.Connection.get` exist to fill "
"this need. For example, say you had an archive file you wanted to upload:"
msgstr ""

#: ../../getting-started.rst:256
msgid ""
"These methods typically follow the behavior of ``cp`` and "
"``scp``/``sftp`` in terms of argument evaluation - for example, in the "
"above snippet, we omitted the filename part of the remote path argument."
msgstr ""

#: ../../getting-started.rst:262
msgid "Multiple actions"
msgstr ""

#: ../../getting-started.rst:264
msgid ""
"One-liners are good examples but aren't always realistic use cases - one "
"typically needs multiple steps to do anything interesting. At the most "
"basic level, you could do this by calling `.Connection` methods multiple "
"times::"
msgstr ""

#: ../../getting-started.rst:273
msgid ""
"You could (but don't have to) turn such blocks of code into functions, "
"parameterized with a `.Connection` object from the caller, to encourage "
"reuse::"
msgstr ""

#: ../../getting-started.rst:280
msgid ""
"As you'll see below, such functions can be handed to other API methods to"
" enable more complex use cases as well."
msgstr ""

#: ../../getting-started.rst:285
msgid "Multiple servers"
msgstr ""

#: ../../getting-started.rst:287
msgid ""
"Most real use cases involve doing things on more than one server. The "
"straightforward approach could be to iterate over a list or tuple of "
"`.Connection` arguments (or `.Connection` objects themselves, perhaps via"
" ``map``)::"
msgstr ""

#: ../../getting-started.rst:302
msgid ""
"This approach works, but as use cases get more complex it can be useful "
"to think of a collection of hosts as a single object. Enter `.Group`, a "
"class wrapping one-or-more `.Connection` objects and offering a similar "
"API; specifically, you'll want to use one of its concrete subclasses like"
" `.SerialGroup` or `.ThreadingGroup`."
msgstr ""

#: ../../getting-started.rst:308
msgid ""
"The previous example, using `.Group` (`.SerialGroup` specifically), looks"
" like this::"
msgstr ""

#: ../../getting-started.rst:327
msgid ""
"Where `.Connection` methods return single ``Result`` objects (e.g. "
"`fabric.runners.Result`), `.Group` methods return `.GroupResult` - "
"`dict`-like objects offering access to individual per-connection results "
"as well as metadata about the entire run."
msgstr ""

#: ../../getting-started.rst:332
msgid ""
"When any individual connections within the `.Group` encounter errors, the"
" `.GroupResult` is lightly wrapped in a `.GroupException`, which is "
"raised. Thus the aggregate behavior resembles that of individual "
"`.Connection` methods, returning a value on success or raising an "
"exception on failure."
msgstr ""

#: ../../getting-started.rst:339
msgid "Bringing it all together"
msgstr ""

#: ../../getting-started.rst:341
msgid ""
"Finally, we arrive at the most realistic use case: you've got a bundle of"
" commands and/or file transfers and you want to apply it to multiple "
"servers. You *could* use multiple `.Group` method calls to do this::"
msgstr ""

#: ../../getting-started.rst:350
msgid ""
"That approach falls short as soon as logic becomes necessary - for "
"example, if you only wanted to perform the copy-and-untar above when "
"``/opt/mydata`` is empty. Performing that sort of check requires "
"execution on a per-server basis."
msgstr ""

#: ../../getting-started.rst:354
msgid ""
"You could fill that need by using iterables of `.Connection` objects "
"(though this foregoes some benefits of using `Groups <.Group>`)::"
msgstr ""

#: ../../getting-started.rst:364
msgid ""
"Alternatively, remember how we used a function in that earlier example? "
"You can go that route instead::"
msgstr ""

#: ../../getting-started.rst:377
msgid ""
"The only convenience this final approach lacks is a useful analogue to "
"`.Group.run` - if you want to track the results of all the "
"``upload_and_unpack`` call as an aggregate, you have to do that yourself."
" Look to future feature releases for more in this space!"
msgstr ""

#: ../../getting-started.rst:384
msgid "Addendum: the ``fab`` command-line tool"
msgstr ""

#: ../../getting-started.rst:386
msgid ""
"It's often useful to run Fabric code from a shell, e.g. deploying "
"applications or running sysadmin jobs on arbitrary servers. You could use"
" regular :ref:`Invoke tasks <defining-and-running-task-functions>` with "
"Fabric library code in them, but another option is Fabric's own "
"\"network-oriented\" tool, ``fab``."
msgstr ""

#: ../../getting-started.rst:392
msgid ""
"``fab`` wraps Invoke's CLI mechanics with features like host selection, "
"letting you quickly run tasks on various servers - without having to "
"define ``host`` kwargs on all your tasks or similar."
msgstr ""

#: ../../getting-started.rst:397
msgid ""
"This mode was the primary API of Fabric 1.x; as of 2.0 it's just a "
"convenience. Whenever your use case falls outside these shortcuts, it "
"should be easy to revert to the library API directly (with or without "
"Invoke's less opinionated CLI tasks wrapped around it)."
msgstr ""

#: ../../getting-started.rst:402
msgid ""
"For a final code example, let's adapt the previous example into a ``fab``"
" task module called ``fabfile.py``::"
msgstr ""

#: ../../getting-started.rst:413
msgid ""
"Not hard - all we did was copy our temporary task function into a file "
"and slap a decorator on it. `~fabric.tasks.task` tells the CLI machinery "
"to expose the task on the command line::"
msgstr ""

#: ../../getting-started.rst:422
msgid ""
"Then, when ``fab`` actually invokes a task, it knows how to stitch "
"together arguments controlling target servers, and run the task once per "
"server. To run the task once on a single server::"
msgstr ""

#: ../../getting-started.rst:428
msgid ""
"When this occurs, ``c`` inside the task is set, effectively, to "
"``Connection(\"web1\")`` - as in earlier examples. Similarly, you can "
"give more than one host, which runs the task multiple times, each time "
"with a different `.Connection` instance handed in::"
msgstr ""

